## UTL_TO_SUMMARY {#GUID-EC9DDB58-6A15-4B36-BA66-ECBA20D2CE57}

Use the `DBMS_VECTOR_CHAIN.UTL_TO_SUMMARY` chainable utility function to generate a summary for textual documents. 

A summary is a short and concise extract with key features of a document that best represents what the document is about as a whole. A summary can be free-form paragraphs or bullet points based on the format that you specify.

Purpose

To perform a text-to-summary transformation by accessing either Oracle Database or a third-party service provider: 

  * Oracle Database as the service provider (default setting): 

Uses the in-house implementation with Oracle Database, where Oracle Text is internally used to extract a summary (gist) from your document using the Oracle Text PL/SQL procedure `CTX_DOC.GIST`. 

  * Third-party summarization model: 

Makes a REST API call to your chosen remote service provider (Cohere, Generative AI, Google AI, Hugging Face, OpenAI, or Vertex AI) or local service provider (Ollama).




> **note:** Currently, `UTL_TO_SUMMARY` does not work for Generative AI because the model and summary endpoint supported for Generative AI have been retired. It will be available in a subsequent release. 

> **note:** WARNING: 

Certain features of the database may allow you to access services offered separately by third-parties, for example, through the use of JSON specifications that facilitate your access to REST APIs. 

Your use of these features is solely at your own risk, and you are solely responsible for complying with any terms and conditions related to use of any such third-party services. Notwithstanding any other terms and conditions related to the third-party services, your use of such database features constitutes your acceptance of that risk and express exclusion of Oracle's responsibility or liability for any damages resulting from such access.

Syntax
```
    DBMS_VECTOR_CHAIN.UTL_TO_SUMMARY (
    DATA          IN CLOB,
    PARAMS        IN JSON default NULL
    ) return CLOB;
```
    

DATA

This function accepts the input data type in plain text as `CLOB`. 

It returns a summary of the input document also as `CLOB`. 

PARAMS

Specify summary parameters in JSON format, depending on the service provider that you want to use for document summarization.

**If using Oracle Database as the provider**: 
```
    {
    "provider"     : "database",
    "glevel"       : "",
    "numParagraphs": ,
    "maxPercent"   : ,
    "num_themes"   : ,
    "language"     : ""
    }
```
    

**Table: Database Provider Parameter Details**

Parameter | Description  
---|---  
`provider` |  Specify `database` (default setting) to access Oracle Database as the provider. Leverages the document `gist` or summary generated by Oracle Text.   
`glevel` |  Format to display the summary: <br>* `SENTENCE` | `S`: <br>As a list of sentences  <br>`PARAGRAPH` | `P`: <br>In a free-form paragraph   
  
`numParagraphs` |  Maximum number of document paragraphs (or sentences) selected for the summary. The default value is `16`. <br>The `numParagraphs` parameter is used only when this parameter yields a smaller summary size than the summary size yielded by the `maxPercent` parameter, because the function always returns the smallest size summary.   
`maxPercent` |  Maximum number of document paragraphs (or sentences) selected for the summary, as a percentage of the total paragraphs (or sentences) in the document. The default value is `10`. <br>The `maxPercent` parameter is used only when this parameter yields a smaller summary size than the summary size yielded by the `numParagraphs` parameter, because the function always returns the smallest size summary.   
`num_themes` |  Number of theme summaries to produce. For example, if you specify `10`, then this function returns the top 10 theme summaries. If you specify `0` or `NULL`, then this function returns all themes in a document. <br>The default value is `50`. If the document contains more than 50 themes, only the top 50 themes show conceptual hierarchy.   
`language` |  Language name of your summary text, as listed in [Supported Languages and Data File Locations](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-8C8AAE2F-E64A-470F-B109-BE1AC2D6E498).   
  
For example:
```
    {
    "provider"          : "database",
    "glevel"            : "sentence",
    "numParagraphs"     : 1
    }
```
    

**If using a third-party provider**: 

Set the following parameters along with additional summarization parameters specific to your provider:
```
    {
    "provider"          : "",
    "credential_name"   : "",
    "url"               : "",
    "model"             : "",
    "transfer_timeout"  : ,
    "max_count": "",
    "": ""
    }
```
    

**Table: Third-Party Provider Parameter Details**

Parameter | Description  
---|---  
`provider` |  Third-party service provider that you want to access to get the summary. A REST call is made to the specified provider to access its text summarization model.<br>Specify one of the following values: <br>* `cohere` <br>`googleai` <br>`huggingface` <br>`ocigenai` <br>`openai` <br>`vertexai`  
  
`credential_name` |  Name of the credential in the form: <br> *`schema`*.*`credential_name`* <br>A credential name holds authentication credentials to enable access to your provider for making REST API calls. <br>You need to first set up your credential by calling the `DBMS_VECTOR_CHAIN.CREATE_CREDENTIAL` helper function to create and store a credential, and then refer to the credential name here. See [CREATE_CREDENTIAL](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-A6E28402-DC43-44C6-A1B2-75C3F270DD76).   
`url` |  URL of the third-party provider endpoint for each REST call, as listed in [Supported Third-Party Provider Operations and Endpoints](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-BE3EE403-CD10-4708-A15F-EFB1FA69DF09).   
`model` |  Name of the third-party text summarization model in the form: <br> *`schema`*.*`model_name`* <br>If the model name is not schema-qualified, then the schema of the procedure invoker is used.<br>**Note**: <br>For Generative AI, you must specify *`schema`*.*`model_name`* . All the third-party models supported for Generative AI are listed in [Supported Third-Party Provider Operations and Endpoints](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-BE3EE403-CD10-4708-A15F-EFB1FA69DF09).   
`transfer_timeout` |  Maximum time to wait for the request to complete. <br>The default value is `60` seconds. You can increase this value for busy web servers.   
`max_count` |  Maximum number of times the API can be called for a given third-party provider.<br>When set to an integer *n*, `max_count` stops the execution of the API for the given provider beyond *n* times. This prevents accidental calling of a third-party over some limit, for example to avoid surpassing the service amount that you have purchased.   
  
**Additional third-party provider parameters**: 

Optionally, specify additional provider-specific parameters.

**Table: Additional REST Provider Parameter Details**

Parameter | Description  
---|---  
`length` |  Approximate length of the summary text: <br>* `SHORT`: <br>Roughly up to 2 sentences  <br>`MEDIUM`: <br>Between 3 and 5 sentences  <br>`LONG`: <br>6 or more sentences  <br>`AUTO`: <br>The model chooses a length based on the input size 
<br>**Note**: <br>For Generative AI, you must enter this value in uppercase.   
`format` |  Format to display the summary: <br>* `PARAGRAPH`: <br>In a free-form paragraph  <br>`BULLETS`: <br>In bullet points 
<br>**Note**: <br>For Generative AI, you must enter this value in uppercase.   
`temperature` |  Degree of randomness used when generating output text, in the range of `0.0-5.0`. <br>To generate the same output for a prompt, use `0`. To generate a random new text for that prompt, increase the temperature. <br>Default temperature is `1` and the maximum temperature is `5`. <br>**Note**: <br>To summarize a text, start with the temperature set to `0`. If you do not require random results, a recommended temperature value is `0.2` for Generative AI and between `0` and `1` for Cohere. Use a higher value if for example you plan to perform a selection of the various summaries afterward. Do not use a high temperature for summarization because a high temperature encourages the model to produce creative text, which might also include hallucinations.   
`extractiveness` |  How much to reuse the input in the summary: <br>* `LOW`: <br>Summaries with low extractiveness tend to paraphrase.  <br>`HIGH`: <br>Summaries with high extractiveness lean toward reusing sentences verbatim. 
<br>**Note**: <br>For Generative AI, you must enter this value in uppercase.   
`max_tokens` |  Maximum number of tokens in the output text.  
`topP` |  Probability of tokens in the output, in the range of `0.0â€“1.0`. <br>A lower value provides less random responses and a higher value provides more random responses.  
`candidateCount` |  Number of response variations to return, in the range of `1-4`.   
`maxOutputTokens` |  Maximum number of tokens to generate for each response.  
  
> **note:** When specifying the `length`, `format`, and `extractiveness` parameters for Generative AI, ensure to enter the values in uppercase letters. 

Let us look at some example configurations for all third-party providers:

> **note:** Important: 

  * The following examples are for illustration purposes. For accurate and up-to-date information on additional parameters to use, refer to your third-party provider's documentation.

  * For a list of all supported REST endpoint URLs, see [Supported Third-Party Provider Operations and Endpoints](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-BE3EE403-CD10-4708-A15F-EFB1FA69DF09). 




Cohere example: 
```
    {
    "provider"          : "cohere",
    "credential_name"   : "COHERE_CRED",
    "url"               : "https://api.cohere.example.com/summarize",
    "model"             : "command",
    "length"            : "medium",
    "format"            : "paragraph",
    "temperature"       : 1.0
    }
```
    

Generative AI example:
```
    {
    "provider"           : "ocigenai",
    "credential_name"    : "OCI_CRED",
    "url"                : "https://generativeai.oci.example.com/summarizeText",
    "model"              : "cohere.command-r-16k",
    "length"             : "MEDIUM",
    "format"             : "PARAGRAPH"
    }
```
    

Google AI example:
```
    {
    "provider"          : "googleai",
    "credential_name"   : "GOOGLEAI_CRED",
    "url"               : "https://googleapis.example.com/models/",
    "model"             : "gemini-pro:generateContent",
    "generation_config" : {
    "temperature"     : 0.9,
    "topP"            : 1,
    "candidateCount"  : 1,
    "maxOutputTokens" : 256
    }
    }
```
    

Hugging Face example:
```
    {
    "provider"          : "huggingface",
    "credential_name"   : "HF_CRED",
    "url"               : "https://api.huggingface.example.co/models/",
    "model"             : "facebook/bart-large-cnn"
    }
```
    

Ollama example:
```
    {
    "provider"          : "ollama",
    "host"              : "local",
    "url"               : "http://localhost:11434/api/generate",
    "model"             : "phi3:mini"
    }
```
    

OpenAI example:
```
    {
    "provider"          : "openai",
    "credential_name"   : "OPENAI_CRED",
    "url"               : "https://api.openai.example.com",
    "model"             : "gpt-4o-mini",
    "max_tokens"        : 256,
    "temperature"       : 1.0
    }
```
    

Vertex AI example:
```
    {
    "provider"          : "vertexai",
    "credential_name"   : "VERTEXAI_CRED",
    "url"               : "https://googleapis.example.com/models/",
    "model"             : "gemini-1.0-pro:generateContent",
    "generation_config" : {
    "temperature"     : 0.9,
    "topP"            : 1,
    "candidateCount"  : 1,
    "maxOutputTokens" : 256
    }
    }
```
    

Examples

  * **Generate summary using Oracle Database**: 

This statement specifies `database` as the provider. Here, the Oracle Text PL/SQL procedure `CTX_DOC.GIST` is internally called to generate a summary of an extract on "Transactions". 
```
    -- select example
    
    set serveroutput on
    
    var params clob;
    begin
    :params := '
    {
    "provider": "database",
    "glevel": "sentence",
    "numParagraphs": 1
    }';
    end;
    /
    
    select dbms_vector_chain.utl_to_summary(
    'A transaction is a logical, atomic unit of work that contains one or more SQL statements.  An RDBMS must be able to group SQL statements so that they are either all committed, which means they are applied to the database, or all rolled back, which means they are undone.  An illustration of the need for transactions is a funds transfer from a savings account to a checking account. The transfer consists of the following separate operations:
    1. Decrease the savings account.
    2. Increase the checking account.
    3. Record the transaction in the transaction journal.
    Oracle Database guarantees that all three operations succeed or fail as a unit. For example, if a hardware failure prevents a statement in the transaction from executing, then the other statements must be rolled back.
    Transactions set Oracle Database apart from a file system. If you perform an atomic operation that updates several files, and if the system fails halfway through, then the files will not be consistent. In contrast, a transaction moves an Oracle database from one consistent state to another. The basic principle of a transaction is "all or nothing": an atomic operation succeeds or fails as a whole.',
    json(:params)) from dual;
    
    -- PL/SQL example
    
    declare
    input clob;
    params clob;
    output clob;
    begin
    input := 'A transaction is a logical, atomic unit of work that contains one or more SQL statements.  An RDBMS must be able to group SQL statements so that they are either all committed, which means they are applied to the database, or all rolled back, which means they are undone.  An illustration of the need for transactions is a funds transfer from a savings account to a checking account. The transfer consists of the following separate operations:
    1. Decrease the savings account.
    2. Increase the checking account.
    3. Record the transaction in the transaction journal.
    Oracle Database guarantees that all three operations succeed or fail as a unit. For example, if a hardware failure prevents a statement in the transaction from executing, then the other statements must be rolled back.
    Transactions set Oracle Database apart from a file system. If you perform an atomic operation that updates several files, and if the system fails halfway through, then the files will not be consistent. In contrast, a transaction moves an Oracle database from one consistent state to another. The basic principle of a transaction is "all or nothing": an atomic operation succeeds or fails as a whole.';
    
    params := '
    {
    "provider": "database",
    "glevel": "sentence",
    "numParagraphs": 1
    }';
    
    output := dbms_vector_chain.utl_to_summary(input, json(params));
    dbms_output.put_line(output);
    if output is not null then
    dbms_lob.freetemporary(output);
    end if;
    exception
    when OTHERS THEN
    DBMS_OUTPUT.PUT_LINE (SQLERRM);
    DBMS_OUTPUT.PUT_LINE (SQLCODE);
    end;
    /
```
    

  * **Generate summary using Generative AI**: 

These statements generate a summary of an extract on "Transactions" by accessing Generative AI as the provider.

Here, the cohere.command-r-16k model is used for the summarization operation. You can replace the `model` value with any other supported model that you want to use with Generative AI, as listed in [Supported Third-Party Provider Operations and Endpoints](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-BE3EE403-CD10-4708-A15F-EFB1FA69DF09). 
```
    -- select example
    
    var params clob;
    begin
    :params := '
    {
    "provider": "ocigenai",
    "credential_name": "OCI_CRED",
    "url": "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/chat",
    "model": "cohere.command-r-16k",
    "temperature": "0.0",
    "extractiveness": "LOW"
    }';
    end;
    /
    
    select dbms_vector_chain.utl_to_summary(
    'A transaction is a logical, atomic unit of work that contains one or more SQL statements.  An RDBMS must be able to group SQL statements so that they are either all committed, which means they are applied to the database, or all rolled back, which means they are undone.  An illustration of the need for transactions is a funds transfer from a savings account to a checking account. The transfer consists of the following separate operations:
    1. Decrease the savings account.
    2. Increase the checking account.
    3. Record the transaction in the transaction journal.
    Oracle Database guarantees that all three operations succeed or fail as a unit. For example, if a hardware failure prevents a statement in the transaction from executing, then the other statements must be rolled back.
    Transactions set Oracle Database apart from a file system. If you perform an atomic operation that updates several files, and if the system fails halfway through, then the files will not be consistent. In contrast, a transaction moves an Oracle database from one consistent state to another. The basic principle of a transaction is "all or nothing": an atomic operation succeeds or fails as a whole.',
    json(:params)) from dual;
    
    -- PL/SQL example
    
    declare
    input clob;
    params clob;
    output clob;
    begin
    input := 'A transaction is a logical, atomic unit of work that contains one or more SQL statements.  An RDBMS must be able to group SQL statements so that they are either all committed, which means they are applied to the database, or all rolled back, which means they are undone.  An illustration of the need for transactions is a funds transfer from a savings account to a checking account. The transfer consists of the following separate operations:
    1. Decrease the savings account.
    2. Increase the checking account.
    3. Record the transaction in the transaction journal.
    Oracle Database guarantees that all three operations succeed or fail as a unit. For example, if a hardware failure prevents a statement in the transaction from executing, then the other statements must be rolled back.
    Transactions set Oracle Database apart from a file system. If you perform an atomic operation that updates several files, and if the system fails halfway through, then the files will not be consistent. In contrast, a transaction moves an Oracle database from one consistent state to another. The basic principle of a transaction is "all or nothing": an atomic operation succeeds or fails as a whole.';
    
    params := '
    {
    "provider": "ocigenai",
    "credential_name": "OCI_CRED",
    "url": "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/chat",
    "model": "cohere.command-r-16k",
    "length": "MEDIUM",
    "format": "PARAGRAPH",
    "temperature": 1.0
    }';
    
    output := dbms_vector_chain.utl_to_summary(input, json(params));
    dbms_output.put_line(output);
    if output is not null then
    dbms_lob.freetemporary(output);
    end if;
    exception
    when OTHERS THEN
    DBMS_OUTPUT.PUT_LINE (SQLERRM);
    DBMS_OUTPUT.PUT_LINE (SQLCODE);
    end;
    /
```
    

  * **End-to-end examples**: 

To run end-to-end example scenarios using this function, see [Generate Summary](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/vecse&id=VECSE-GUID-DEEC1985-6785-45B1-8480-05AD67FB3F9F). 




**Parent topic:** [DBMS_VECTOR_CHAIN](dbms_vector_chain-vecse.md)
